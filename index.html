<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>OOP in Python</title>

	<meta name="description" content="Slides for the talk on Python in science for PyLadies Berlin">
	<meta name="author" content="Ivana Kajic">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="css/night.css" id="theme" />

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', use the PDF print sheet -->
	<script>
		document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<div class="reveal">

		<div class="slides">

<section data-markdown data-separator="^\n---\n$">
<script type="text/template">

### An introduction to Object-Oriented Programming with Python

<img src="img/objects_small.png" width="40%"/>

<small> PyLadies Berlin, April 2014 </small>

<small> [Ivana Kajic](mailto:ivana.kajic@gmail.com) | Student @ TU Berlin | [@kajic_ivana](http://twitter.com/kajic_ivana) </small>

---

## What are we going to do today?

* Remind us of some Python basics: variables and functions 

* Give a motivation and an intuitive definition of object-orientation 

* Familiarize ourselves with the OOP terminology and see several examples of OOP concepts in Python 

* Get some work done in the hands-on session 

---

## Some information before we start

* The slides are available [online](http://ikajic.github.io/python-oop/) : ikajic.github.io/python-oop/

* They contain links to tutorials, explanations and other useful material I'll mention throughout the talk

* Code examples I'll be showing are copy-pasted from the Python interpreter

---

## Python Interpreter

* A program that executes commands written in Python

<img src="img/pythoninterpreter.png" width="80%"/>

---

## Reminder: variables

* Variables are containers that store different types of data

* Their values can be modified (thus the name), manipulated, displayed on the screen...

* Let's inspect some of the simple data types in Python

    ```python
    >>> x = 8
    >>> type(x)
    <type 'int'>
    >>> x + 221
    229
    >>> ages = [18, 43, 21, 66]
    >>> type(ages)
    <type 'list'>
    ```

---

## More variables

* The data types we have seen in the previous example are called [built-in Types](https://docs.python.org/2/library/stdtypes.html) and there are many of them

* Some of the Built-in Types are: 
	* `int` - integers (e.g. 2, -10)
	* `str` -  strings, a sequence of characters (e.g. "Monday", "123")
	* `list` - list as a collection of values (e.g. [1, 2, 3], ["Hey", "there", 22])
	* `dict` - dictionary, mapping between labels and values

---

## Reminder: functions
 
* Functions are operations on variables 

* For example: addition (+) is a mathematical operation that can be expressed as a function: ``f(a,b) = a + b``
	* `f` is the name of the function, `a` and `b` are the arguments 

* In Python, we can define the function `f` and use it:
    ```python
    >>> def f(a, b):
    ...     # variable res stores the result
    ...     res = 0
    ...     if a > b:
    ...         res = a - b
    ...     else:
    ...         res = b - a
    ...     return res
    ... 
    >>> a = 3
    >>> b = 4
    >>> f(a,b)
    1

    ```

---

## Organizing functions

* Imagine having a `functions.py` module that contains a bunch of different functions called in another `.py` script (here we listed only function definitions):

    ```python
    ...
    def add_floats(a, b):
    def print_float(a):
    def clear_float(a):
    def add_ints(a, b):
    def print_int(a):
    def clear_int(a):
    def add_strings(a, b):
    def print_string(a):
    def clear_string(a):
    ...
    ```

---

## Imports 

* If you wanted use these functions in some other script, you would [import](http://scipy-lectures.github.io/intro/language/reusing_code.html) them as a module using the following command:

    ```python
    import functions 

    x = 3.4
    y = 4.3
    functions.add_floats(x, y)
    ```

* Or alternatively, import only needed functions:

```python
from functions import add_floats, print_float
```

---

## Analyzing `functions.py`

* Some pieces of code are redundant  
	 * `add_floats` and `add_ints` might contain the same code for addition
	 * `print_string` and `print_int` could also be similar
	 
* For a new data type we might feel tempted to copy-paste existing functions and just replace names (bad idea!)

* We must know and explicitly list all function names we want to import 
```python
from functions import add_floats, print_float, clear_float, add_ints, print_int, clear_int
```

---

## Is there an alternative to organizing the code?

* Yes! We could use object-oriented programming

* But in order to understand how, let's first do a little detour...

---

<div style="float:left;"> 
<img src="img/library.png" width="50%" /> <vsmall> [\*] </vsmall>
<img src="img/books.png" width="35%" /> <vsmall> [**] </vsmall>
</div>

  <vsmall> [\*] http://mythologica.ro/wp-content/uploads/2013/05/110920AncientLibraryMelkMonasteryAustria.jpg </vsmall>
<br>
<vsmall> [**] http://organiseme.files.wordpress.com/2011/06/pile_of_books.jpg </vsmall>


---

## Describing a book

* More or less, every book can be described using following attributes:
<center> <img src="img/book_mod.png"  /> </center>

---

## Things you can do with a library book

* Borrow: **who** borrowed the book, **when** and for how **long**

* Return: **who** returned the book, **when**, what was the **condition** of the book upon giving it back

* Repair: **what** is a damage, **where** is it located and **how** much does it cost?

* You can also read a book, destroy it (spill coffee on it), etc... 

---

## Important things to keep in mind...

* When describing what a book is with different attributes, we didn't describe a particular instance of book but the "idea" of a book

* However, all books we know need to have these attributes

* We mentioned things which can be done with this book

---

## First class

```python
>>> class Book(object): # <-- definition of a class
...     """This class describes the concept of a book.""" # <-- docstring
...     
...     evil = 0 # <-- class varible
...     
...     def __init__(self, title, author, isbn): # <-- this is a method
...         self.title = title # <-- this is an atribute
...         self.author = author # <-- so is this
...         self.isbn = isbn
...         self.state = "Available"
...     
...     def borrow(self, name, date): # <-- another method
...         self.name = name
...         self.state = "Borrowed"
...         self.date = date.getCurrentDate()  # <-- a function defined in a module date
...
...     def repair(self, page, cost):
...         self.cost = cost
...         self.what = page
```

---

## Classes and objects

* Class is a description or a representation of an object, defined using the keyword `class`:
        class Book(object):

* Object is an instance of a class:
    ```python
    >>> favorite_book = Book("Pride and Prejudice", "Jane Austen", "123")
    >>> type(fav)
    <type 'instance'>
    >>> boring_book = Book("Washing machines of the 20th century", "Boring Guy", "456")
    ```
    * `favorite_book` and `boring_book` are objects

---

## Class members

* Class members are methods and attributes

* Python uses `self` to refer to the class members and distinguish them from local variables

```python
...     def __init__(self, title, author, isbn): 
...         self.title = title 
...
...     def borrow(self, name, date):
...         self.name = name

```

---

## Methods

* All functions defined inside a class are called methods and must have the argument `self` in the list of arguments
        >>> def borrow(self, name, date): 
    
* `__init__` is a special method called **constructor** 
    * Every time an object is created, Python calls the constructor of the class
    * It is useful to set the values of instance attributes upon the creation of the object
    
* Methods are accessed using the dot notation
```python
    >>> favorite_book = Book("Pride and Prejudice", "Jane Austen", "123")
    >>> favorite_book.borrow()
```

---

## Attributes
      
* Attributes (also called instance attributes) are variables inside a class and are also accessed using the dot notation
```python
    >>> favorite_book.title
    >>> favorite_book.author
```            
* We can add new attributes at any time:
        >>> favorite_book.times_read = 0
        >>> favorite_book.times_read = favorite_book.times_read+1

* Class attributes (also called class variables) are defined within a class, but outside of a method and they are rarely used in practice

    ```python
    >>> class Book(object):
    ...     evil = 0 # <-- class varible
    ...     def __init__(self, title, author, isbn): # <-- this is a method
    ```

---

## Remarks

* If you want to inspect elements of a class or an object, you can use the `dir` command:
    ```python
    >>> boring_book = Book("Washing machines of the 20th century", "Boring Guy", "456")    
    >>> dir(boring_book)
    ['__class__', '__delattr__', '__dict__', '__doc__', '__format__', 
    '__getattribute__', '__hash__', '__init__', '__module__', '__new__', 
    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
    '__str__', '__subclasshook__', '__weakref__', 
    'author', 'borrow', 'evil', 'isbn', 'repair', 'state', 'title']
    ```
* What other class members mean, especially those with underscores (`__`) is explained [here](http://www.rafekettler.com/magicmethods.html)

---

## Advanced OOP: Inheritance

* [Inheritance](https://docs.python.org/2/tutorial/classes.html#inheritance) is used to derive from an existing class which is called a parent or base class:

    ```python
    >>> class Fruit: # define parent class
    ...     def __init__(self):
    ...         print "Hi there! I'm a fruit and I'm growing"            
    ...     def eat(self):
    ...         print "I love eating fruit!"
    ... 
    >>> class Pineapple(Fruit): # define one child class
    ...     def __init__(self):       
    ...         print "I am a yummi pineapple!"  
    ...
    >>> p = Pineapple()
    I am a yummi pineapple!
    >>> p.eat()
    I love eating fruit!
    ```

---

### Advanced OOP: Inheritance [cont'd]
    
* We can also [override](http://en.wikipedia.org/wiki/Method_overriding) methods defined in a parent class
    ```python
    >>> class Fruit:        # define parent class
    ...     def __init__(self):
    ...         print "Hi there! I'm a fruit and I'm growing"            
    ...     def eat(self):
    ...         print "I love eating fruit!"
    ...     
    >>> class Banana(Fruit): # define another child class
    ...     def eat(self):
    ...         print "I like only bananas!"
    ...
    >>> b = Banana()
    print "Hi there! I'm a fruit and I'm growing"
    >>> b.eat()
    I like only bananas!    
    ```
* Use the [`super`](http://learnpythonthehardway.org/book/ex44.html) keyword in the constructor to invoke the constructor of the parent class
    ```python
    super(Banana, self).__init__()   
    ```

---

### Advanced OOP: Encapsulation

* [Encapsulation](http://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private) is the concept in OOP for hiding some class members, so they cannot be used in objects

* By agreement, encapsulation is not completely supported in Python, but one can prefix the attribute with an underscore (e.g. `_price`) to denote that this attribute is not meant to be used outside of the class

    ```python
    >>> class Banana(Fruit): # define another child class
    ...     _price = 100
    ...     def eat(self):
    ...         print "I like only bananas!"
    ...
    ```
* However, it is still possible to access the attribute:
    ```python
    >>> b = Banana()
    >>> b._price
    100
    ```

---

## Back to our data types

* Create **class** as a blueprint and **objects** that are concrete examples of that class (dots are hiding more complex code which is omitted for brevity)

```python
class DataType():
    ...

class Integer(DataType):
    ...
    
class String(DataType):    
    ...
    
>>> n = Integer(3) # <-- object
>>> s = String("Popocatepetl") # <-- another object
>>> n.print()
Printing an integer: 3
>>> s.print()
Printing a string: "Popocatepetl"
>>> s.clear()
>>> s.print()
Printing a string: ""
```

---

## Wait... What just happened?

* We created classes for each data type and every class inherited functionality from the `DataType` class

* Although we had different objects (some were ints, some strings) we still used them in the same way

    ```python
    >>> n.print() # n is an Integer
    >>> s.print() # s is a String
    ```

* We added additional behaviour to the print command
    ```python
    >>> n.print()
    Printing an integer: 3
    ```

---

## In the end... Why OOP?

* Having many functions and variables can get very messy!	

* Object-oriented approach is a way to organize and structure your code 

* Group pieces of code that logically fit together

* Understanding how OOP works helps understanding Python internals, as well as some of libraries you might have used (Django, Flask, SciPy...)

---

## Hands-on session

* There are two tutorials, pick the one you like!

* [non-OOP basic Python](http://learnpythonthehardway.org/book/): Variables, functions, files for beginners
    * Recommended for programming/Python first timers
    * The tutorial guides you through the installation process (Exercise 0) and continues with simple exercises (Exercise 1 - Exercise 4)
    
* [OOP](https://github.com/ikajic/python-oop/): First steps in OOPv
    * Recommended for all who already know some Python
    * There are several exercises of varying complexity, it starts with the simplest ones: creation of a class, inspection of class members and playing around with instances of that class
    * Last few exercises are a bit more advanced (but fun!)


</script>            
</section>                                       

   		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.min.js"></script>

	<script>

		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			margin: 0.0,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				//{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});

	</script>

</body>
</html>
